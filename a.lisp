(defmacro range(n) `(loop for i from 0 to ,n collect i))
(defmacro fm (a) `(format t "~A~%" ,a))
(defmacro toint(s) `(parse-integer ,s))
(defmacro foldl (fn lst initval) `(reduce ,fn ,lst :initial-value ,initval))
(defmacro foldl1 (fn lst) `(reduce ,fn ,lst))

(defmacro dbgfmt(&body body)
  `(format t ,(format nil "~{~A~}~~%" (mapcar (lambda(a) (format nil "~(~A:~~A ~)" a)) body)) ,@body))
  (let ((a 1)
  (b '(a b c))
  (c 1000))
  (dbgfmt a b c))

(defun flatten1(lst)
  (nreverse (reduce (lambda (acc a)
					  (reduce (lambda (acc a)
								(cons a acc))
							  a :initial-value acc))
					lst :initial-value nil)))

(defun permutations(lst)
  (labels ((skip(i n lst acc)
			 (cond ((null lst) acc)
				   ((= i n) (skip (1+ i) n (cdr lst) acc))
				   (t (skip (1+ i) n (cdr lst) (cons (car lst) acc)))))
		   (rec (lst acc acc0)
				(if (null lst)
				  (cons acc acc0)
				  (flatten1 (mapcar (lambda(i) (rec (nreverse (skip 0 i lst nil)) (cons (nth i lst) acc) acc0)) (loop for i from 0 to (1- (length lst)) collect i)))
				  ))
				)
	(rec lst nil nil)))

(defun subsequences(nums fn)
	(labels ((rec (acc lst)
				  (unless (null lst)
					(let ((a (car lst)))
					  (when (funcall fn (cons a acc))
						(rec acc (cdr lst))
						(rec (cons a acc) (cdr lst)))))))
	  (rec nil nums)))

(defun splitat (c line)
  (labels ((rec (line acc)
				(let ((pos (position-if (lambda(cc) (char= c cc)) line)))
				  (if pos
					  (rec (subseq line (1+ pos)) (cons (subseq line 0 pos) acc))
					(cons line acc)))))
	(rec line nil)))
(defun readline (callback)
  (labels ((rec (i)
				(let ((line (read-line nil nil)))
				  (when (not (zerop (length line)))
					(funcall callback line i)
					(rec (1+ i))
					)
				  )
				))
	(rec 0)))
(defun start()
  (readline (lambda(line i)
			  (cond ((zerop i))
					((evenp i) (mapcar (lambda(s) (format t "~A~%" s)) (splitat #\space line)))))))
(start)
